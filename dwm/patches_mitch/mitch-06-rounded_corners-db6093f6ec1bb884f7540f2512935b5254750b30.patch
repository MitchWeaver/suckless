--- dwm.c	2020-03-23 18:24:17.104022867 -0400
+++ dwmb.c	2020-03-23 18:23:41.390691008 -0400
@@ -39,6 +39,7 @@
 #ifdef XINERAMA
 #include <X11/extensions/Xinerama.h>
 #endif /* XINERAMA */
+#include <X11/extensions/shape.h>
 #include <X11/Xft/Xft.h>
 
 #include "drw.h"
@@ -242,6 +243,9 @@
 static void xinitvisual();
 static void zoom(const Arg *arg);
 
+static void roundcorners(Client* c);
+static void unroundcorners(Client* c);
+
 /* variables */
 static const char broken[] = "broken";
 static char stext[256];
@@ -1125,6 +1129,7 @@
 		unfocus(selmon->sel, 0);
 	c->mon->sel = c;
 	arrange(c->mon);
+	roundcorners(c);
 	XMapWindow(dpy, c->win);
 	focus(NULL);
 }
@@ -1399,6 +1404,7 @@
 			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
 				resize(c, c->x, c->y, nw, nh, 1);
 
+			roundcorners(c);
 			break;
 		}
 	} while (ev.type != ButtonRelease);
@@ -1410,6 +1416,7 @@
 		selmon = m;
 		focus(NULL);
 	}
+	roundcorners(c);
 }
 
 void
@@ -1549,6 +1556,7 @@
 		c->bw = 0;
 		c->isfloating = 1;
 		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+		unroundcorners(c);
 		XRaiseWindow(dpy, c->win);
 	} else if (!fullscreen && c->isfullscreen){
 		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
@@ -1561,6 +1569,7 @@
 		c->w = c->oldw;
 		c->h = c->oldh;
 		resizeclient(c, c->x, c->y, c->w, c->h);
+		roundcorners(c);
 		arrange(c->mon);
 	}
 }
@@ -1769,6 +1778,7 @@
 			resize(c, m->wx + mw - c->bw, m->wy + ty, m->ww - mw, h - c->bw, False);
 			ty += HEIGHT(c) - c->bw;
 		}
+		roundcorners(c);
 	}
 }
 
@@ -2305,3 +2315,72 @@
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
 }
+
+void
+roundcorners(Client *c)
+{
+	int diam;
+	Pixmap mask;
+	GC shapegc;
+
+	if (CORNER_RADIUS < 0)
+		return;
+
+	if (!c || c->isfullscreen)
+		return;
+
+	diam = 2 * CORNER_RADIUS;
+	if (c->w < diam || c->h < diam)
+		return;
+
+	if (!(mask = XCreatePixmap(dpy, c->win, c->w, c->h, 1)))
+		return;
+	
+	if (!(shapegc = XCreateGC(dpy, mask, 0, NULL))){
+	    XFreePixmap(dpy, mask);
+	    free(shapegc);
+	    return;
+	}
+
+	XFillRectangle(dpy, mask, shapegc, 0, 0, c->w, c->h);
+	XSetForeground(dpy, shapegc, 1);
+
+	/* topleft, topright, bottomleft, bottomright
+	 * man XArc - positive is counterclockwise
+	 */
+	XFillArc(dpy, mask, shapegc, 0, 		0, 			diam, diam, 90 * 64, 90 * 64);
+	XFillArc(dpy, mask, shapegc, c->w - diam - 1, 	0, 			diam, diam, 0 * 64, 90 * 64);
+	XFillArc(dpy, mask, shapegc, 0,			c->h - diam - 1,	diam, diam, -90 * 64, -90 * 64);
+	XFillArc(dpy, mask, shapegc, c->w - diam - 1,	c->h - diam - 1,	diam, diam, 0 * 64, -90 * 64);
+
+	XFillRectangle(dpy, mask, shapegc, CORNER_RADIUS, 0, c->w - diam, c->h);
+	XFillRectangle(dpy, mask, shapegc, 0, CORNER_RADIUS, c->w, c->h - diam);
+	XShapeCombineMask(dpy, c->win, ShapeBounding, 0, 0, mask, ShapeSet);
+	XFreePixmap(dpy, mask);
+	XFreeGC(dpy, shapegc);
+}
+
+void
+unroundcorners(Client *c)
+{
+	Pixmap mask;
+	GC shapegc;
+
+	if (CORNER_RADIUS < 0 || !c)
+		return;
+
+	if (!(mask = XCreatePixmap(dpy, c->win, c->w, c->h, 1)))
+		return;
+	
+	if (!(shapegc = XCreateGC(dpy, mask, 0, NULL))){
+	    XFreePixmap(dpy, mask);
+	    free(shapegc);
+	    return;
+	}
+
+	XSetForeground(dpy, shapegc, 1);
+	XFillRectangle(dpy, mask, shapegc, 0, 0, c->w, c->h);
+	XShapeCombineMask(dpy, c->win, ShapeBounding, 0, 0, mask, ShapeSet);
+	XFreePixmap(dpy, mask);
+	XFreeGC(dpy, shapegc);
+}
